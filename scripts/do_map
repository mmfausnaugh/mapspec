#!/usr/bin/env python
import numpy as np
import scipy as sp
import matplotlib.pyplot as plt
import argparse
import sys
import os
DIR = os.path.abspath(os.path.dirname(__file__))
sys.path.insert(0, os.path.join(DIR, '..'))

from mapspec.spectrum import *
from mapspec.mapspec import *

if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog="do_map",
                                     description = "Given a reference spectrum "
                                     "and wavelength window for an emission line, transform "
                                     "a spectrum to match the reference as closely "
                                     "as possible.  The transform model"
                                     "includes wavelength shifts, flux rescaling, "
                                     "and resolution adjustments.  As a default, this "
                                     "program will save the transformed spectra, "
                                     "a table of transform model parameters, and "
                                     "the MCMC posterior sample chains." ) 

    parser.add_argument("-r", "--reference_spec", metavar="FILE",
                        help = "Reference spectrum saved as a text file, "
                        "usually after it has been smoothed."
                        )
    parser.add_argument("-w","--wv_window_file", metavar="FILE",
                        help = "Text file with wavelength windows in 2-column 3-row format.  "
                        "Columns are blue/red edges of the wavelength ranges, "
                        "and rows are emission line range, "
                        "blue continuum range, and red continuum range.")
    parser.add_argument("-i","--interp_style", metavar="STRING",
                        default= "linear",
                        help = "String specifying interpolation method, "
                        "should be either 'linear', 'sinc', 'bspline', or "
                        "a string accepted by scipy (i.e., scipy.interpolate.interp1d(kind=interp_style) ).")
    parser.add_argument("-s","--spec_list", metavar="FILE",
                        help = "Text file with list of spectrum files to align to reference, "
                        "one filename per line.  Spectrum files should be saved as text files.")
    parser.add_argument("-o","--outfile", metavar="FILE", default = "mapspec.params",
                        help = "Output file tabulating mapspec fitting results.  "
                        "Records the parameters of the model with the lowest chi^2 "
                        "out of no smoothing, Gaussian smoothing, or Gauss-Hermite smoothing.")
    parser.add_argument("--random_seed", metavar="INT", type=int, default=10101,
                        help="Seed for random number generator, to ensure that the MCMC "
                        "samples are repeatable.  Change to get slightly different posterior "
                        "sample.  Note that this will also change the mapspec model parameters.")
    parser.add_argument("--no_chains", action="store_true",
                        help = "Do not save MCMC chains if this flag is set.")    
    parser.add_argument("--save_covar", action="store_true",
                         help = "Save the covariance matrix of spectrum "
                         "after running through mapspec model if this flag is set.")

    args = parser.parse_args()
    if args.reference_spec == None:
        print('--reference_spec is "None", but this argument is required.  Exiting do_map.')
        sys.exit()
    if args.wv_window_file == None:
        print('--wv_wavelength_file is "None", but this argument is required. Exiting do_map.')
        sys.exit()
    if args.spec_list == None:
        print('--spec_list is "None", but this argument is required. Exiting do_map.')
        sys.exit()


    np.random.seed(args.random_seed)
        

    #How to interpolate?  Note that only linear interpolation does the
    #errors properly, for now
    istyle = args.interp_style

    #What spectrum to use as a reference?
    sref   = TextSpec(args.reference_spec, style=istyle)

    #file with window for alignment, i.e., [OIII]lambda 5007.  Format is:
    #line 1:  wavelength_of_line_low, wavelength_of_line_high
    #line 2:  continuum window 1 (low, high)
    #line 3: continuum window 2(low, high)
    #see run_map.sh for more
    window = np.genfromtxt(args.wv_window_file)

    #pops out the line from the reference spectrum
    lref   = EmissionLine(sref,window[0],[ window[1],window[2] ] )

    #list of spectra to align
    speclist = np.genfromtxt(args.spec_list,dtype=str)

    #output file of parameters
    fout = open(args.outfile,'a')

    fout.write(
        "{:>30s}{:>12s}{:>12s}{:>12s}{:>12s}{:>9s}{:>12s}{:>12s}{:>12s}{:>12s}{:>9s}{:>12s}{:>12s}{:>12s}{:>12s}{:>12s}{:>12s}{:>9s}\n".format(
            'file name','cc shift',
            'chi2','shift','scale','frac',
            'chi2','shift','scale','width','frac',
            'chi2','shift','scale','width','h3','h4','frac')
    )


    #write covariances?
    print('save_covar',args.save_covar, 'no_chains',args.no_chains)
    if args.save_covar:
        get_covar = True
        if os.path.isdir('covar_matrices') == False:
            os.mkdir('covar_matrices')
    else:
        get_covar = False

    if args.no_chains:
        get_chains = False
    else:
        get_chains = True
        if os.path.isdir('chains') == False:
            os.mkdir('chains')
    print('get_covar',get_covar, 'get_chains',get_chains)
    
    #plt.ion()
    for spec in speclist:
        print(spec)
        s = TextSpec(spec,style=istyle)

        #best to cross correlate local to the line, +/- say 100 wavelength units
        dwv = sref.wv[1] - sref.wv[0]
        mref = (sref.wv > window[0][0] - 100*dwv )&( sref.wv < window[0][1] + 100*dwv)
        m = (s.wv > window[0][0] - 100*dwv )&( s.wv < window[0][1] + 100*dwv)
        s0 = get_cc(sref.f[mref], s.f[m], sref.wv[mref], s.wv[m])
        #    s0 = get_cc(sref.f,s.f,sref.wv,s.wv)
        s.wv -= s0[0]

        l = EmissionLine(s,window[0],[ window[1],window[2] ])
        l.set_interp(style=istyle)

        f   = RescaleModel(lref,kernel="Delta")
        try: 
            chi2_delta,p_delta,frac_delta = metro_hast(2000,l,f,keep=False)
            print(frac_delta)
        except:
            chi2_delta,p_delta,frac_delta = 999999,{'shift':-99, 'scale':-99}, 0 
     

        f    = RescaleModel(lref,kernel="Gauss")
 
        #keep = True returns the chain, which can be saved and used
        #latter for getting model errors (mode_rescale.py).
        chi2_gauss,p_gauss,frac_gauss,chain_gauss = metro_hast(10000,l,f,keep=True)
        print(frac_gauss)
        #       Try this code to watch the chain as it progresses
        #        plt.ion()
        #        chi2_gauss,p_gauss,frac_gauss,chain_gauss = metro_hast(5000,l,f,keep=True,plot=True)
        #if a shift+rescale with no smoothing is better, just do that
        if chi2_delta < chi2_gauss:
            f.p = {'shift':p_delta['shift'], 'scale':p_delta['scale'], 'width': 0.001 }
        else:
            f.p = p_gauss

        sout,dummy = f.output(s,getcovar=get_covar)
        np.savetxt('scale_'+spec,np.c_[sout.wv,sout.f,sout.ef],fmt='% 6.2f % 4.4e % 4.4e')
        
        if get_covar:
            np.savetxt('covar_matrices/covar_'+spec,covar)
        if get_chains:
            chain_gauss.save('chains/'+spec+'.chain.gauss')

    
        f    = RescaleModel(lref,kernel="Hermite")
        #    Here is an example of how to put in a prior----we are using the
        #    posterior distribution of the kernel width from the pure Gaussian
        #    as a prior on the width for the Gauss-Hermite kernel.
        #    'burn=0.75' means we throw out the first 3/4 of the chain
        #    (assumed to be burn in).

        #    f.make_dist_prior(chain_gauss,'width', burn=0.75)

        #    Or, you can specify an analytic function, if say, you have a
        #    guess of what the width should be----here, the prior is a
        #    Gaussian of mean 1.8 angstroms and std 1.0 angstroms.
        
        #    def wprior(x,params):
        #        return np.exmp(-0.5*(x - params[0])**2/ (params[1])**2 )
        #    f.make_func_prior('width', wprior, [1.8, 1.0] )

        try:
            chi2_herm,p_herm,frac_herm,chain_herm = metro_hast(100000,l,f,keep=True)
            print(frac_herm)
        except:
            chi2_herm,p_herm,frac_herm = 999, {'shift':99,'scale':-99,
                                               'width':-99,'h3':-99,'h4':-99}, 0 

        
        if chi2_delta < chi2_herm:
            f.p = {'shift':p_delta['shift'], 'scale':p_delta['scale'],
                   'width': 0.001 , 'h3':0.0, 'h4':0.0}
        else:
            f.p = p_herm

        sout,dummy = f.output(s,getcovar=get_covar)
    
        fout.write(
            "{:30s}{:>12.4f}{:>12.2f}{:>12.4f}{:>12.4f}{:>9.2f}{:>12.2f}{:>12.4f}{:>12.4f}{:>12.4f}"
            "{:>9.2f}{:>12.2f}{:>12.4f}{:>12.4f}{:>12.4f}{:>12.4e}{:>12.4e}{:>9.4f}\n".format(
                spec,s0[0],
                chi2_delta,p_delta['shift'],p_delta['scale'], frac_delta,
                chi2_gauss,p_gauss['shift'],p_gauss['scale'],p_gauss['width'],frac_gauss,
                chi2_herm,p_herm['shift'],p_herm['scale'],p_herm['width'],p_herm['h3'],p_herm['h4'],frac_herm)
        )
        fout.flush()
        np.savetxt('scale.h._'+spec,np.c_[sout.wv,sout.f,sout.ef],fmt='% 6.2f % 4.4e % 4.4e')
        if get_covar:
            np.savetxt('covar_matrices/covar.h._'+spec,covar)
        if get_chains:
            chain_herm.save('chains/'+spec+'.chain.herm')


        
        plt.close('all')
    fout.close()
