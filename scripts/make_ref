#!python
import numpy as np
import scipy as sp
from scipy.signal import correlate
import matplotlib.pyplot as plt
import argparse
import os
import sys
DIR = os.path.abspath(os.path.dirname(__file__))
sys.path.insert(0, os.path.join(DIR, '..'))

from mapspec.spectrum import Spectrum, EmissionLine, TextSpec
from copy import deepcopy

"""
This will combine a list of spectra using a weighted average.

The program runs an MCMC to calculate the shift that best aligns the
spectra, in order to use a consistent wavelength grid.  The fit uses
some target emission line.

'Best fit' is not rigorously defined, because different shifts cause
different overlaps of pixels, so the degrees of freedom are changing.
Nevertheless, it seems to be good enough for most purposes.

input is a list of spectra 'speclist' that are combined with a
weighted average.  The shifts are solved to align with the FIRST
spectrum in this list.

The user must enter a file designating the window from which to
extract the emission line.  This follows the usual format, i.e., 3
lines specifying:

line_blue_edge     line_red_edge
bluecont_blue_edge bluecont_red_edge
redcont_blue_edge  redcont_red_edge

"""


def get_chi2(s1,s2,shift):
    trim = int(round(abs(shift[0]/(s1.wv[1] - s1.wv[0])))) + 1
    if trim == 0: trim = 1
    xnew = s2.wv[trim : -trim] - shift
    #resample the reference at the new wavelength grid

    y1,z1 = s1.interp(xnew)

    return np.sum( 
        (y1 - s2.f[trim: - trim])**2/(z1**2 + s2.ef[trim: - trim]**2)
        )

def get_cc(y1,y2,x):
    cc = correlate(y1,y2,mode='same')
    i  = np.where(cc == cc.max())[0]
    shift = (x[1] - x[0] )*(cc.size//2 - i)

    return shift

def tidy(xout,yout,zout):
    xmin = xout[0]
    for x in xout:
        print(x.size, x[0])
        if x.size < xmin.size:
            xmin = deepcopy(x)

    print(xmin)
    xout  = np.array(xout,dtype=object)
    for i in range(np.shape(xout)[0]):
        j = np.in1d(xout[i],xmin)

        yout[i] = yout[i][j]
        zout[i] = zout[i][j]

    yout  = np.array(yout)
    zout  = np.array(zout)
    print(np.shape(xout),np.shape(yout),np.shape(zout))
#    print yout
    ymean = np.sum( yout/zout**2,axis = 0 )/np.sum(1./zout**2, axis = 0)
    error = np.sqrt( 
        1./np.sum(1./zout**2,axis = 0) 
        )

    return xmin,ymean,error


def HM(ntrial,s1,s2,p):

    deltawv = s1.wv[1] - s1.wv[2]

    chi2 = get_chi2(s1,s2,p)
    chi2best = 1.e12

    pbest = deepcopy(p)

    accept = 0

    for i in range(ntrial):

        ptry = p + sp.randn()*0.1*deltawv
 
        chi2try = get_chi2(s1,s2,ptry)
        if i%10 == 0 :
            print(i,chi2best,chi2,chi2try)
        if chi2try < 0:
            next
        

        if chi2try < chi2:
            
            p = deepcopy(ptry)
            chi2 = deepcopy(chi2try)

            accept += 1
            if chi2 < chi2best:
                pbest = deepcopy(ptry)
                chi2best = deepcopy(chi2try)


        else:
            prob = np.exp(-chi2try/chi2)
            r = sp.rand()
            if r <= prob:
                p = deepcopy(ptry)
                chi2 = deepcopy(chi2try)
                accept += 1

    return chi2best,pbest,accept/float(ntrial)

if __name__ == "__main__":

    parser = argparse.ArgumentParser(prog="do_map",
                                     description ="This program takes a list of spectra, "
                                     " aligns them in wavelength, and combines them as "
                                     "a weighted average.  The program solves for wavelength "
                                     "shifts based on an emission line specified by "
                                     "wv_window_file.  If the list of spectra were taken on "
                                     "photometric nights, the resulting 'reference' spectrum "
                                     "is accurately flux calibrated.")

    parser.add_argument("-s","--spec_list", metavar="FILE",
                        help = "Text file with list of spectrum files to combine,  "
                        "one filename per line.  Spectrum files should be saved as text files.")
    parser.add_argument("-w","--wv_window_file", metavar="FILE",
                        help = "Text file with wavelength windows in 2-column 3-row format.  "
                        "Columns are blue/red edges of the wavelength ranges, "
                        "and rows are emission line range, "
                        "blue continuum range, and red continuum range.")
    parser.add_argument("-o","--outfile", metavar="FILE", 
                        help = "Output reference spectrum is saved in a text file with this name.")
    args = parser.parse_args()
    if args.outfile is None:
        print('--outfile is "None", but this argument is required.  Exiting do_map.')
        sys.exit()
    if args.wv_window_file is None:
        print('--wv_wavelength_file is "None", but this argument is required. Exiting do_map.')
        sys.exit()
    if args.spec_list is None:
        print('--spec_list is "None", but this argument is required. Exiting do_map.')
        sys.exit()

    #list of spectra for the reference
    reflist = np.genfromtxt(args.spec_list,dtype=str)
    #window for line to align
    window = np.genfromtxt(args.wv_window_file)


    S,L = [],[]
    for ref in reflist:
        s = TextSpec(ref)
        s.set_interp(style='linear')
        #    m= (s.wv > 4432)*(s.wv <7500)
        #    s.wv = s.wv[m]
        #    s.f  = s.f[m]
        #    s.ef = s.ef[m]

        S.append(s)

        #    plt.plot(s.wv,s.f,'k')
        #    plt.show()
        #trimmax = 0

    xout = []
    yout = []
    zout = []

    shiftout = []

    lref = EmissionLine(S[0],window[0],[window[1],window[2]])
    dwv = S[0].wv[1] - S[0].wv[0]

    for s in S[1::]:

        #best to cross correlate local to the line, +/- say 100 wavelength units
        mref = (S[0].wv > window[0][0] - 100*dwv )&( S[0].wv < window[0][1] + 100*dwv)
        m = (s.wv > window[0][0] - 100*dwv )&( s.wv < window[0][1] + 100*dwv)
        shift0 = get_cc(S[0].f[mref], s.f[m], S[0].wv[mref])
        print('shift0',shift0)
        ##    shift0 = 0
        l = EmissionLine(s,window[0],[window[1],window[2]])
        #    print l.ef[0:5]
        #    input()
        #    plt.plot(l.wv,l.f,'k')
        #    plt.plot(lref.wv,lref.f,'r')
        #    plt.show()
        chi,shiftuse,frac = HM(1000,lref,l,shift0)

        print('chi2,shiftuse,frac')
        print(chi,shiftuse,frac)

        shiftout.append(shiftuse)
        s.wv -= shiftuse

        trim = int(round(abs(shiftuse[0]/(s.wv[1] - s.wv[0])))) + 1
        #    if trim > trimmax: trimmax = trim
        #    print 'trim',trimmax
        y1,z1 = s.interp(S[0].wv[trim:-trim])
        #    plt.plot(S[0].wv[trim:-trim],y1,'k')
        #    plt.plot(S[0].wv[trim:-trim],z1,'r')
        #    plt.show()

        xout.append(S[0].wv[trim:-trim])
        yout.append(y1)
        zout.append(z1)


    xout.append(S[0].wv)
    yout.append(S[0].f)
    zout.append(S[0].ef)

    xref,yref,zref = tidy(xout,yout,zout)


    np.savetxt(args.outfile, np.c_[xref,yref,zref])
    np.savetxt('ref_shifts.dat',np.c_[shiftout])
